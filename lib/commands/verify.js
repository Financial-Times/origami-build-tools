/*global require, process, __dirname, exports*/
/*jshint globalstrict: true */

"use strict";

var path = require('path'),
    async = require('async'),
    fs = require('fs'),
	commandLine = require('../command-line'),
    childProcess = require("child_process"),
    files = require('../files'),
    log = require('../log.js'),
    verifyExists = require('../verify');


/**
 * Adds a wildcard glob onto the end of a pathname if it is a directory.
 *
 * scss-lint's exclusions are inconsistent with gitignore which is the same
 * format jshint uses this works around the inconsistency so the same
 * exclusions list can be used.
 *
 * @returns {string}
 */
function addWildCardIfDirectory(pathname) {

    var isExistingDirectory =
        fs.existsSync(pathname) &&
        fs.statSync(pathname).isDirectory();

    if (isExistingDirectory) {
        return path.join(pathname, '/*');
    }

    return pathname;
}

/**
 * Create a linter task which launches a child process based on a command.
 */
function linterTask(command, args) {
    return function (callback) {
		commandLine.run(command, args, callback);
    };
}

/**
 * Create the SCSS Linter Task making use of the scss-lint command line tool.
 */
function createScssLinterTask() {

    var configPath = __dirname + '/../../config/scss-lint.yml',
        excludePaths = files.getGitIgnorePaths().map(addWildCardIfDirectory),
        sourcePaths = [
            path.join(process.cwd(), '/*.scss'),
            path.join(process.cwd(), '/**/**/*.scss')
        ],
		command = 'scss-lint',
        args = ['--config=' + configPath, '--exclude=' + excludePaths.join(',')].concat(sourcePaths);

    if (!verifyExists.mainSass()) {
        return function(callback) { callback(false, 'No main.scss'); };
    }

    return linterTask(command, args);
}

/**
 * Create the Javsacript Linter Task making use of the JSHint command line
 * tool.
 */
function createJavascriptLinterTask() {

    var configPath = __dirname + '/../../config/jshint.json',
        excludePath = path.join(process.cwd(), '/.gitignore'),
        command = 'jshint',
		args = ['--config', configPath, '--exclude-path=' + excludePath, './'];

    if(!verifyExists.mainJs()) {
        return function(callback) { callback(false, 'No main.js'); };
    }

    return function(callback) {
		files.getNodeModulesDirectoryInUse(function(err, modulespath) {
			if (err) {
				callback(err);
				return;
			}

			var jsHintCommand = path.join(modulespath, '.bin/', command);
			var task = linterTask(jsHintCommand, args);
			task(callback);
		});
	}
}

exports.run = function(callback) {

    // The run method should be a function requiring a single callback argument,
    //  which accepts an (error, result) argument list.
    var verifierTasks = [
        {
			name: 'scss-lint',
			run: createScssLinterTask(),
			transformOutput: function(output) {
				var lines = output.split('\n');
				if (lines.length) {
					return lines.map(function(line) {
						return line.replace(path.join(process.cwd(), path.sep), '');
					}).join('\n') + '\n' + lines.length + ' errors\n';
				}
				return '';
			}
		},
        {
			name: 'jshint',
			run: createJavascriptLinterTask()
		}
    ];

    /**
     * For each error output an error message.
     *
     * @params {Array} taskErrors An array of errors generated by tasks.
     */
    function outputResults(taskErrors) {
        taskErrors.forEach(function(taskError) {
            log.primary(taskError.name);
            log.primaryError(taskError.stdout);
        });
    }

    // COMPLEX: This needs some explaining:
    //   In order to run all the verifier tasks and aggregate all errors,
    //   we need to perform some trickery to accumulate errors as results. By
    //   default the async library halts as soon an error is encountered.
    //   This could potentially cause problems where pedantic linting errors
    //   could be hide more sinister errors in other linter tasks.
    //
    //   To prevent this behaviour, `map` is called using a callback which wraps
    //   errors generated by the task in a new object which is then
    //   passed as a result rather than an error to the callback expected by
    //   the async library.
    //
    //   The final callback should always be called with an `errors` array
    //   (which is empty if no errors occurred). This callback should never
    //   see the error object in its first argument.
    async.map(verifierTasks, function(task, mapCallback) {

        task.run(function(err, output) {
			var transformedOutput = '';
			if (err) {
				transformedOutput = err.stdout;

				if (task.transformOutput) {
					transformedOutput = task.transformOutput(transformedOutput);
				}
			}

			var wrappedError = err ? {
				'err': err,
				'stdout': transformedOutput,
				'name': task.name
			} : false;

            mapCallback(false, wrappedError);
        });

    }, function(err, errors) {
        // Remove false values (as they were successful tasks)
        var errors = errors.filter(function(error) { return !!error; });
        outputResults(errors);
        callback(errors.length, errors);
    });
};
